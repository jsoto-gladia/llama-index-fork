"""Base schema for data structures."""

import json
import textwrap
import uuid
from abc import abstractmethod
from dataclasses import dataclass
from enum import Enum, auto
from hashlib import sha256
from io import BytesIO
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union

from dataclasses_json import DataClassJsonMixin
from llama_index.core.bridge.pydantic import BaseModel, Field
from llama_index.core.instrumentation import DispatcherSpanMixin
from llama_index.core.utils import SAMPLE_TEXT, truncate_text
from typing_extensions import Self

if TYPE_CHECKING:
    from haystack.schema import Document as HaystackDocument
    from llama_index.core.bridge.langchain import Document as LCDocument
    from semantic_kernel.memory.memory_record import MemoryRecord
    from llama_cloud.types.cloud_document import CloudDocument


DEFAULT_TEXT_NODE_TMPL = "{metadata_str}\n\n{content}"
DEFAULT_METADATA_TMPL = "{key}: {value}"
# NOTE: for pretty printing
TRUNCATE_LENGTH = 350
WRAP_WIDTH = 70

ImageType = Union[str, BytesIO]


class BaseComponent(BaseModel):
    """Base component object to capture class names."""

    class Config:
        """
        Defines a static method, `schema_extra`, which adds a property to a schema
        with the name of a class inheriting from `BaseComponent`.

        """
        @staticmethod
        def schema_extra(schema: Dict[str, Any], model: "BaseComponent") -> None:
            """Add class name to schema."""
            schema["properties"]["class_name"] = {
                "title": "Class Name",
                "type": "string",
                "default": model.class_name(),
            }

    @classmethod
    def class_name(cls) -> str:
        """
        Get the class name, used as a unique ID in serialization.

        This provides a key that makes serialization robust against actual class
        name changes.
        """
        return "base_component"

    def json(self, **kwargs: Any) -> str:
        return self.to_json(**kwargs)

    def dict(self, **kwargs: Any) -> Dict[str, Any]:
        """
        Creates a new dictionary containing the properties of the object, including
        the "class_name" property that is computed using the class's `class_name()`
        method.

        Args:
            **kwargs (Any): Dictionary of keyword arguments

        Returns:
            Dict[str, Any]: A dictionary containing the keys "class_name" with the
            value of self.class_name() and the rest of the data returned by super().dict(**kwargs).

        """
        data = super().dict(**kwargs)
        data["class_name"] = self.class_name()
        return data

    def __getstate__(self) -> Dict[str, Any]:
        """
        Removes unnecessary data from the instance's state before serializing it,
        including the tokenizer attribute and any private attribute values.

        Returns:
            Dict[str, Any]: A dictionary containing the object's state, with certain
            keys removed or modified to follow the conventions of Python's
            serialization mechanism.

        """
        state = super().__getstate__()

        # tiktoken is not pickleable
        # state["__dict__"] = self.dict()
        state["__dict__"].pop("tokenizer", None)

        # remove local functions
        keys_to_remove = []
        for key, val in state["__dict__"].items():
            if key.endswith("_fn"):
                keys_to_remove.append(key)
            if "<lambda>" in str(val):
                keys_to_remove.append(key)
        for key in keys_to_remove:
            state["__dict__"].pop(key, None)

        # remove private attributes -- kind of dangerous
        state["__private_attribute_values__"] = {}

        return state

    def __setstate__(self, state: Dict[str, Any]) -> None:
        # Use the __dict__ and __init__ method to set state
        # so that all variable initialize
        """
        Reinitializes instance variables from a dictionary, ensuring all variables
        are properly initialized upon state restoration.

        Args:
            state (Dict[str, Any]): Passed as an argument to the method representing
                a dictionary containing the state of the object.

        """
        try:
            self.__init__(**state["__dict__"])  # type: ignore
        except Exception:
            # Fall back to the default __setstate__ method
            super().__setstate__(state)

    def to_dict(self, **kwargs: Any) -> Dict[str, Any]:
        """
        Transforms class attributes into a dictionary representation, including a
        custom attribute for the class name.

        Args:
            **kwargs (Any): Dictionary of keyword arguments

        Returns:
            Dict[str, Any]: A dictionary containing class name and other attributes
            generated by calling method `dict` with keyword arguments **kwargs

        """
        data = self.dict(**kwargs)
        data["class_name"] = self.class_name()
        return data

    def to_json(self, **kwargs: Any) -> str:
        """
        Converts data from a Python object to a JSON string by calling the `to_dict`
        method and then using `json.dumps`.

        Args:
            **kwargs (Any): Dictionary of keyword arguments

        Returns:
            str: A string representation of a dictionary data generated from calling
            the `to_dict` method with the provided keyword arguments.

        """
        data = self.to_dict(**kwargs)
        return json.dumps(data)

    # TODO: return type here not supported by current mypy version
    @classmethod
    def from_dict(cls, data: Dict[str, Any], **kwargs: Any) -> Self:  # type: ignore
        """
        Takes a dictionary of data and updates it with any additional keyword
        arguments provided, while removing certain unneeded keys such as "relationships"
        and "class_name". It then creates an instance of the class using the updated
        data.

        Args:
            data (Dict[str, Any]): Used to initialize an object of a class.
            **kwargs (Any): Dictionary of keyword arguments

        Returns:
            Self: A subclass of `Dict`.

        """
        if isinstance(kwargs, dict):
            data.update(kwargs)

        data.pop("relationships", None)
        data.pop("class_name", None)
        return cls(**data)

    @classmethod
    def from_json(cls, data_str: str, **kwargs: Any) -> Self:  # type: ignore
        """
        Loads JSON data into an instance of the class using the `json.loads()`
        function and returns an instance of the same class.

        Args:
            data_str (str): A JSON-formatted string that contains the data to be
                parsed and converted into an instance of the `cls` class.
            **kwargs (Any): Dictionary of keyword arguments

        Returns:
            Self: A subclass of the class `cls`.

        """
        data = json.loads(data_str)
        return cls.from_dict(data, **kwargs)


class TransformComponent(BaseComponent, DispatcherSpanMixin):
    """Base class for transform components."""

    class Config:
        arbitrary_types_allowed = True

    @abstractmethod
    def __call__(self, nodes: List["BaseNode"], **kwargs: Any) -> List["BaseNode"]:
        """Transform nodes."""

    async def acall(self, nodes: List["BaseNode"], **kwargs: Any) -> List["BaseNode"]:
        """Async transform nodes."""
        return self.__call__(nodes, **kwargs)


class NodeRelationship(str, Enum):
    """Node relationships used in `BaseNode` class.

    Attributes:
        SOURCE: The node is the source document.
        PREVIOUS: The node is the previous node in the document.
        NEXT: The node is the next node in the document.
        PARENT: The node is the parent node in the document.
        CHILD: The node is a child node in the document.

    """

    SOURCE = auto()
    PREVIOUS = auto()
    NEXT = auto()
    PARENT = auto()
    CHILD = auto()


class ObjectType(str, Enum):
    """
    Defines four constants representing different types of objects: `TEXT`, `IMAGE`,
    `INDEX`, and `DOCUMENT`. These constants are defined using the `auto()` function,
    which automatically generates a unique name for each constant.

    Attributes:
        TEXT (auto): Automatically generated by the compiler.
        IMAGE (auto): Automatically generated by the compiler, serving as a unique
            identifier for each object instance.
        INDEX (auto): Automatically generated by the compiler.
        DOCUMENT (str|Document): Generated automatically by the compiler.

    """
    TEXT = auto()
    IMAGE = auto()
    INDEX = auto()
    DOCUMENT = auto()


class MetadataMode(str, Enum):
    """
    Defines three enumeration values: `ALL`, `EMBED`, and `LLM`. These values
    represent different modes for managing metadata in a neural network.

    Attributes:
        ALL (str): Defined as "all".
        EMBED (str): One of the possible values that can be assigned to the mode
            parameter of various methods in the class, indicating that the metadata
            should be embedded within the associated media file rather than being
            stored separately.
        LLM (str): 3-letter abbreviation for "Linguistic Labeling Mode".
        NONE (str): Defined as having a value of "none". It indicates that no
            metadata should be included

    """
    ALL = "all"
    EMBED = "embed"
    LLM = "llm"
    NONE = "none"


class RelatedNodeInfo(BaseComponent):
    """
    Serves as a container for various metadata related to a node, including its
    ID, type (optional), and custom metadata field. It also has a static method
    to return the class name.

    Attributes:
        node_id (str): Used to identify a unique node within a hierarchical structure.
        node_type (Optional[ObjectType]): Used to specify the type of node associated
            with the related information.
        metadata (Dict[str, Any]): Used to store arbitrary metadata related to the
            node.
        hash (Optional[str]): Used to store a unique identifier for each related
            node information instance.

    """
    node_id: str
    node_type: Optional[ObjectType] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)
    hash: Optional[str] = None

    @classmethod
    def class_name(cls) -> str:
        """
        Returns a string value indicating the type of related node information.

        Returns:
            str: "RelatedNodeInfo".

        """
        return "RelatedNodeInfo"


RelatedNodeType = Union[RelatedNodeInfo, List[RelatedNodeInfo]]


# Node classes for indexes
class BaseNode(BaseComponent):
    """Base node Object.

    Generic abstract interface for retrievable nodes

    """

    class Config:
        """
        Determines if configuration values can be populated by field names and
        validates assignments.

        Attributes:
            allow_population_by_field_name (bool): Set to True, indicating that
                the configuration object can be populated by field names directly
                instead of through a specific method.
            validate_assignment (bool): Set to `True`, indicating that assignment
                to a field name is validated.

        """
        allow_population_by_field_name = True
        # hash is computed on local field, during the validation process
        validate_assignment = True

    id_: str = Field(
        default_factory=lambda: str(uuid.uuid4()), description="Unique ID of the node."
    )
    embedding: Optional[List[float]] = Field(
        default=None, description="Embedding of the node."
    )

    """"
    metadata fields
    - injected as part of the text shown to LLMs as context
    - injected as part of the text for generating embeddings
    - used by vector DBs for metadata filtering

    """
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="A flat dictionary of metadata fields",
        alias="extra_info",
    )
    excluded_embed_metadata_keys: List[str] = Field(
        default_factory=list,
        description="Metadata keys that are excluded from text for the embed model.",
    )
    excluded_llm_metadata_keys: List[str] = Field(
        default_factory=list,
        description="Metadata keys that are excluded from text for the LLM.",
    )
    relationships: Dict[NodeRelationship, RelatedNodeType] = Field(
        default_factory=dict,
        description="A mapping of relationships to other node information.",
    )

    @classmethod
    @abstractmethod
    def get_type(cls) -> str:
        """Get Object type."""

    @abstractmethod
    def get_content(self, metadata_mode: MetadataMode = MetadataMode.ALL) -> str:
        """Get object content."""

    @abstractmethod
    def get_metadata_str(self, mode: MetadataMode = MetadataMode.ALL) -> str:
        """Metadata string."""

    @abstractmethod
    def set_content(self, value: Any) -> None:
        """Set the content of the node."""

    @property
    @abstractmethod
    def hash(self) -> str:
        """Get hash of node."""

    @property
    def node_id(self) -> str:
        """
        Retrieves and returns the `id` attribute of the object, converted to a string.

        Returns:
            str: A unique identifier assigned to each node in the graph

        """
        return self.id_

    @node_id.setter
    def node_id(self, value: str) -> None:
        """
        Sets the `id_` attribute to a provided string value, serving as an identifier
        for the node.

        Args:
            value (str): Set to a new value for the node, updating its ID attribute.

        """
        self.id_ = value

    @property
    def source_node(self) -> Optional[RelatedNodeInfo]:
        """Source object node.

        Extracted from the relationships field.

        """
        if NodeRelationship.SOURCE not in self.relationships:
            return None

        relation = self.relationships[NodeRelationship.SOURCE]
        if isinstance(relation, list):
            raise ValueError("Source object must be a single RelatedNodeInfo object")
        return relation

    @property
    def prev_node(self) -> Optional[RelatedNodeInfo]:
        """Prev node."""
        if NodeRelationship.PREVIOUS not in self.relationships:
            return None

        relation = self.relationships[NodeRelationship.PREVIOUS]
        if not isinstance(relation, RelatedNodeInfo):
            raise ValueError("Previous object must be a single RelatedNodeInfo object")
        return relation

    @property
    def next_node(self) -> Optional[RelatedNodeInfo]:
        """Next node."""
        if NodeRelationship.NEXT not in self.relationships:
            return None

        relation = self.relationships[NodeRelationship.NEXT]
        if not isinstance(relation, RelatedNodeInfo):
            raise ValueError("Next object must be a single RelatedNodeInfo object")
        return relation

    @property
    def parent_node(self) -> Optional[RelatedNodeInfo]:
        """Parent node."""
        if NodeRelationship.PARENT not in self.relationships:
            return None

        relation = self.relationships[NodeRelationship.PARENT]
        if not isinstance(relation, RelatedNodeInfo):
            raise ValueError("Parent object must be a single RelatedNodeInfo object")
        return relation

    @property
    def child_nodes(self) -> Optional[List[RelatedNodeInfo]]:
        """Child nodes."""
        if NodeRelationship.CHILD not in self.relationships:
            return None

        relation = self.relationships[NodeRelationship.CHILD]
        if not isinstance(relation, list):
            raise ValueError("Child objects must be a list of RelatedNodeInfo objects.")
        return relation

    @property
    def ref_doc_id(self) -> Optional[str]:
        """Deprecated: Get ref doc id."""
        source_node = self.source_node
        if source_node is None:
            return None
        return source_node.node_id

    @property
    def extra_info(self) -> Dict[str, Any]:
        """TODO: DEPRECATED: Extra info."""
        return self.metadata

    def __str__(self) -> str:
        """
        Generates a string representation of the node by truncating its content,
        wrapping it to a specified width, and adding the node ID and original text
        as a suffix.

        Returns:
            str: A string that consists of the node ID followed by the wrapped text.

        """
        source_text_truncated = truncate_text(
            self.get_content().strip(), TRUNCATE_LENGTH
        )
        source_text_wrapped = textwrap.fill(
            f"Text: {source_text_truncated}\n", width=WRAP_WIDTH
        )
        return f"Node ID: {self.node_id}\n{source_text_wrapped}"

    def get_embedding(self) -> List[float]:
        """Get embedding.

        Errors if embedding is None.

        """
        if self.embedding is None:
            raise ValueError("embedding not set.")
        return self.embedding

    def as_related_node_info(self) -> RelatedNodeInfo:
        """Get node as RelatedNodeInfo."""
        return RelatedNodeInfo(
            node_id=self.node_id,
            node_type=self.get_type(),
            metadata=self.metadata,
            hash=self.hash,
        )


class TextNode(BaseNode):
    """
    Represents a text node in a document, with properties for its text content,
    MIME type, start and end character indices, metadata template, and metadata
    values. It also provides methods for getting and setting the text content,
    metadata, and node information.

    Attributes:
        text (str): Default empty string value representing the text content of
            the node.
        mimetype (str): Defaulted to "text/plain". It represents the MIME type of
            the node's content.
        start_char_idx (Optional[int]): Defaulted to None, indicating the index
            of the starting character of the text content within a larger document
            or field.
        end_char_idx (Optional[int]): Defaulted to None, indicating the index of
            the last character of the node's text content.
        text_template (str): A template for how text is formatted with placeholders
            for content and metadata strings.
        metadata_template (str): Used to format metadata fields with placeholders
            for key and value.
        metadata_seperator (str): Defaulted to a newline character(\n). It represents
            the separator between metadata fields when converting to string.

    """
    text: str = Field(default="", description="Text content of the node.")
    mimetype: str = Field(
        default="text/plain", description="MIME type of the node content."
    )
    start_char_idx: Optional[int] = Field(
        default=None, description="Start char index of the node."
    )
    end_char_idx: Optional[int] = Field(
        default=None, description="End char index of the node."
    )
    text_template: str = Field(
        default=DEFAULT_TEXT_NODE_TMPL,
        description=(
            "Template for how text is formatted, with {content} and "
            "{metadata_str} placeholders."
        ),
    )
    metadata_template: str = Field(
        default=DEFAULT_METADATA_TMPL,
        description=(
            "Template for how metadata is formatted, with {key} and "
            "{value} placeholders."
        ),
    )
    metadata_seperator: str = Field(
        default="\n",
        description="Separator between metadata fields when converting to string.",
    )

    @classmethod
    def class_name(cls) -> str:
        """
        Returns a string representing the class name of the object.

        Returns:
            str: "TextNode".

        """
        return "TextNode"

    @property
    def hash(self) -> str:
        """
        Generates a unique hash value for the node by combining the text and
        metadata using SHA-256 hashing algorithm, storing it as a hexadecimal
        string property.

        Returns:
            str: A SHA-256 hash of the concatenation of the text and metadata properties.

        """
        doc_identity = str(self.text) + str(self.metadata)
        return str(sha256(doc_identity.encode("utf-8", "surrogatepass")).hexdigest())

    @classmethod
    def get_type(cls) -> str:
        """Get Object type."""
        return ObjectType.TEXT

    def get_content(self, metadata_mode: MetadataMode = MetadataMode.NONE) -> str:
        """Get object content."""
        metadata_str = self.get_metadata_str(mode=metadata_mode).strip()
        if not metadata_str:
            return self.text

        return self.text_template.format(
            content=self.text, metadata_str=metadata_str
        ).strip()

    def get_metadata_str(self, mode: MetadataMode = MetadataMode.ALL) -> str:
        """Metadata info string."""
        if mode == MetadataMode.NONE:
            return ""

        usable_metadata_keys = set(self.metadata.keys())
        if mode == MetadataMode.LLM:
            for key in self.excluded_llm_metadata_keys:
                if key in usable_metadata_keys:
                    usable_metadata_keys.remove(key)
        elif mode == MetadataMode.EMBED:
            for key in self.excluded_embed_metadata_keys:
                if key in usable_metadata_keys:
                    usable_metadata_keys.remove(key)

        return self.metadata_seperator.join(
            [
                self.metadata_template.format(key=key, value=str(value))
                for key, value in self.metadata.items()
                if key in usable_metadata_keys
            ]
        )

    def set_content(self, value: str) -> None:
        """Set the content of the node."""
        self.text = value

    def get_node_info(self) -> Dict[str, Any]:
        """Get node info."""
        return {"start": self.start_char_idx, "end": self.end_char_idx}

    def get_text(self) -> str:
        return self.get_content(metadata_mode=MetadataMode.NONE)

    @property
    def node_info(self) -> Dict[str, Any]:
        """Deprecated: Get node info."""
        return self.get_node_info()


# TODO: legacy backport of old Node class
Node = TextNode


class ImageNode(TextNode):
    """Node with image."""

    # TODO: store reference instead of actual image
    # base64 encoded image str
    image: Optional[str] = None
    image_path: Optional[str] = None
    image_url: Optional[str] = None
    image_mimetype: Optional[str] = None
    text_embedding: Optional[List[float]] = Field(
        default=None,
        description="Text embedding of image node, if text field is filled out",
    )

    @classmethod
    def get_type(cls) -> str:
        """
        Returns the string "IMAGE".

        Returns:
            str: The object's type represented as a string.

        """
        return ObjectType.IMAGE

    @classmethod
    def class_name(cls) -> str:
        """
        Returns a string representing the image node's class name.

        Returns:
            str: A string containing the text "ImageNode".

        """
        return "ImageNode"

    def resolve_image(self) -> ImageType:
        """Resolve an image such that PIL can read it."""
        if self.image is not None:
            import base64

            return BytesIO(base64.b64decode(self.image))
        elif self.image_path is not None:
            return self.image_path
        elif self.image_url is not None:
            # load image from URL
            import requests

            response = requests.get(self.image_url)
            return BytesIO(response.content)
        else:
            raise ValueError("No image found in node.")


class IndexNode(TextNode):
    """Node with reference to any object.

    This can include other indices, query engines, retrievers.

    This can also include other nodes (though this is overlapping with `relationships`
    on the Node class).

    """

    index_id: str
    obj: Any = None

    def dict(self, **kwargs: Any) -> Dict[str, Any]:
        """
        Creates a dictionary containing the node's properties and an optional
        serialized version of its obj attribute, using `doc_to_json` or `json.dumps`.

        Args:
            **kwargs (Any): Dictionary of keyword arguments

        Returns:
            Dict[str, Any]: A dictionary containing the serialized form of the
            IndexNode's obj attribute.

        """
        from llama_index.core.storage.docstore.utils import doc_to_json

        data = super().dict(**kwargs)

        try:
            if self.obj is None:
                data["obj"] = None
            elif isinstance(self.obj, BaseNode):
                data["obj"] = doc_to_json(self.obj)
            elif isinstance(self.obj, BaseModel):
                data["obj"] = self.obj.dict()
            else:
                data["obj"] = json.dumps(self.obj)
        except Exception:
            raise ValueError("IndexNode obj is not serializable: " + str(self.obj))

        return data

    @classmethod
    def from_text_node(
        cls,
        node: TextNode,
        index_id: str,
    ) -> "IndexNode":
        """Create index node from text node."""
        # copy all attributes from text node, add index id
        return cls(
            **node.dict(),
            index_id=index_id,
        )

    # TODO: return type here not supported by current mypy version
    @classmethod
    def from_dict(cls, data: Dict[str, Any], **kwargs: Any) -> Self:  # type: ignore
        """
        Converts a Python dict representation of an object into an IndexNode
        instance, handling various types of objects and recursively parsing complex
        ones using the json_to_doc function.

        Args:
            data (Dict[str, Any]): Used to pass a dictionary containing data that
                will be used to create an instance of the `Self` class.
            **kwargs (Any): Dictionary of keyword arguments

        Returns:
            Self: An instance of the class `TextNode` or a dictionary containing
            the parsed object.

        """
        output = super().from_dict(data, **kwargs)

        obj = data.get("obj", None)
        parsed_obj = None

        if isinstance(obj, str):
            parsed_obj = TextNode(text=obj)
        elif isinstance(obj, dict):
            from llama_index.core.storage.docstore.utils import json_to_doc

            # check if its a node, else assume stringable
            try:
                parsed_obj = json_to_doc(obj)
            except Exception:
                parsed_obj = TextNode(text=str(obj))

        output.obj = parsed_obj

        return output

    @classmethod
    def get_type(cls) -> str:
        """
        Returns the string value "INDEX", indicating that the class represents an
        index node in a data structure.

        Returns:
            str: The ObjectType constant named INDEX.

        """
        return ObjectType.INDEX

    @classmethod
    def class_name(cls) -> str:
        """
        Simply returns a string value of "IndexNode".

        Returns:
            str: "IndexNode".

        """
        return "IndexNode"


class NodeWithScore(BaseComponent):
    """
    Extends `BaseComponent` and provides additional methods to access a node's
    score, get its text, metadata, and embedding. It also defines custom string
    representation and property definitions for its attributes.

    Attributes:
        node (BaseNode): Used to represent the underlying node in the tree structure.
        score (Optional[float]): Used to store a score for the node.

    """
    node: BaseNode
    score: Optional[float] = None

    def __str__(self) -> str:
        """
        Generates a string representation of an instance by printing its node and
        score as floating-point numbers with precision 3 digits, or "None" if the
        score is nonexistent.

        Returns:
            str: A string representation of the node object.

        """
        score_str = "None" if self.score is None else f"{self.score: 0.3f}"
        return f"{self.node}\nScore: {score_str}\n"

    def get_score(self, raise_error: bool = False) -> float:
        """Get score."""
        if self.score is None:
            if raise_error:
                raise ValueError("Score not set.")
            else:
                return 0.0
        else:
            return self.score

    @classmethod
    def class_name(cls) -> str:
        """
        Defines a string representing the name of the class.

        Returns:
            str: "NodeWithScore".

        """
        return "NodeWithScore"

    ##### pass through methods to BaseNode #####
    @property
    def node_id(self) -> str:
        """
        Returns the node ID of the underlying Node object.

        Returns:
            str: A unique identifier for the nodes of the graph represented by its
            instance.

        """
        return self.node.node_id

    @property
    def id_(self) -> str:
        """
        Returns the ID of its parent Node object.

        Returns:
            str: The ID of the node that the class instance represents.

        """
        return self.node.id_

    @property
    def text(self) -> str:
        """
        Determines the text value of an instance based on its node attributes and
        raises a ValueError if the node is not a TextNode.

        Returns:
            str: The text content of a `TextNode`.

        """
        if isinstance(self.node, TextNode):
            return self.node.text
        else:
            raise ValueError("Node must be a TextNode to get text.")

    @property
    def metadata(self) -> Dict[str, Any]:
        """
        Returns a dictionary containing metadata associated with the node, such
        as score values.

        Returns:
            Dict[str, Any]: A dictionary containing metadata for the current node.

        """
        return self.node.metadata

    @property
    def embedding(self) -> Optional[List[float]]:
        """
        Returns the embedding of the node, which is an optional list of floating-point
        numbers.

        Returns:
            Optional[List[float]]: A list of floating-point numbers representing
            the node's embedding values.

        """
        return self.node.embedding

    def get_text(self) -> str:
        """
        Retrieves the text content of a node, checking if it's a TextNode and
        returning its get_text() value otherwise raising a ValueError for non-TextNodes.

        Returns:
            str: The text contained within the provided node.

        """
        if isinstance(self.node, TextNode):
            return self.node.get_text()
        else:
            raise ValueError("Node must be a TextNode to get text.")

    def get_content(self, metadata_mode: MetadataMode = MetadataMode.NONE) -> str:
        return self.node.get_content(metadata_mode=metadata_mode)

    def get_embedding(self) -> List[float]:
        return self.node.get_embedding()


# Document Classes for Readers


class Document(TextNode):
    """Generic interface for a data document.

    This document connects to data sources.

    """

    # TODO: A lot of backwards compatibility logic here, clean up
    id_: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique ID of the node.",
        alias="doc_id",
    )

    _compat_fields = {"doc_id": "id_", "extra_info": "metadata"}

    @classmethod
    def get_type(cls) -> str:
        """Get Document type."""
        return ObjectType.DOCUMENT

    @property
    def doc_id(self) -> str:
        """Get document ID."""
        return self.id_

    def __str__(self) -> str:
        """
        Returns a string representation of the document, including its ID and
        truncated text with wraparound for display purposes.

        Returns:
            str: A string representation of the DocId and the truncated text
            followed by a wrapped text.

        """
        source_text_truncated = truncate_text(
            self.get_content().strip(), TRUNCATE_LENGTH
        )
        source_text_wrapped = textwrap.fill(
            f"Text: {source_text_truncated}\n", width=WRAP_WIDTH
        )
        return f"Doc ID: {self.doc_id}\n{source_text_wrapped}"

    def get_doc_id(self) -> str:
        """TODO: Deprecated: Get document ID."""
        return self.id_

    def __setattr__(self, name: str, value: object) -> None:
        """
        Sets attributes on the document object by first checking for compatibility
        with the given name and value, and then calling the parent class's
        implementation of `__setattr__`.

        Args:
            name (str): Used to specify the name of the attribute being set.
            value (object): Used to assign a new value to a field of an object.

        """
        if name in self._compat_fields:
            name = self._compat_fields[name]
        super().__setattr__(name, value)

    def to_langchain_format(self) -> "LCDocument":
        """Convert struct to LangChain document format."""
        from llama_index.core.bridge.langchain import Document as LCDocument

        metadata = self.metadata or {}
        return LCDocument(page_content=self.text, metadata=metadata)

    @classmethod
    def from_langchain_format(cls, doc: "LCDocument") -> "Document":
        """Convert struct from LangChain document format."""
        return cls(text=doc.page_content, metadata=doc.metadata)

    def to_haystack_format(self) -> "HaystackDocument":
        """Convert struct to Haystack document format."""
        from haystack.schema import Document as HaystackDocument

        return HaystackDocument(
            content=self.text, meta=self.metadata, embedding=self.embedding, id=self.id_
        )

    @classmethod
    def from_haystack_format(cls, doc: "HaystackDocument") -> "Document":
        """Convert struct from Haystack document format."""
        return cls(
            text=doc.content, metadata=doc.meta, embedding=doc.embedding, id_=doc.id
        )

    def to_embedchain_format(self) -> Dict[str, Any]:
        """Convert struct to EmbedChain document format."""
        return {
            "doc_id": self.id_,
            "data": {"content": self.text, "meta_data": self.metadata},
        }

    @classmethod
    def from_embedchain_format(cls, doc: Dict[str, Any]) -> "Document":
        """Convert struct from EmbedChain document format."""
        return cls(
            text=doc["data"]["content"],
            metadata=doc["data"]["meta_data"],
            id_=doc["doc_id"],
        )

    def to_semantic_kernel_format(self) -> "MemoryRecord":
        """Convert struct to Semantic Kernel document format."""
        import numpy as np
        from semantic_kernel.memory.memory_record import MemoryRecord

        return MemoryRecord(
            id=self.id_,
            text=self.text,
            additional_metadata=self.get_metadata_str(),
            embedding=np.array(self.embedding) if self.embedding else None,
        )

    @classmethod
    def from_semantic_kernel_format(cls, doc: "MemoryRecord") -> "Document":
        """Convert struct from Semantic Kernel document format."""
        return cls(
            text=doc._text,
            metadata={"additional_metadata": doc._additional_metadata},
            embedding=doc._embedding.tolist() if doc._embedding is not None else None,
            id_=doc._id,
        )

    def to_vectorflow(self, client: Any) -> None:
        """Send a document to vectorflow, since they don't have a document object."""
        # write document to temp file
        import tempfile

        with tempfile.NamedTemporaryFile() as f:
            f.write(self.text.encode("utf-8"))
            f.flush()
            client.embed(f.name)

    @classmethod
    def example(cls) -> "Document":
        """
        Creates a new document with sample text and metadata.

        Returns:
            "Document": An instance of the `Document` class with pre-defined
            properties of text and metadata.

        """
        return Document(
            text=SAMPLE_TEXT,
            metadata={"filename": "README.md", "category": "codebase"},
        )

    @classmethod
    def class_name(cls) -> str:
        """
        Returns a string representing the name of the class.

        Returns:
            str: "Document".

        """
        return "Document"

    def to_cloud_document(self) -> "CloudDocument":
        """Convert to LlamaCloud document type."""
        from llama_cloud.types.cloud_document import CloudDocument

        return CloudDocument(
            text=self.text,
            metadata=self.metadata,
            excluded_embed_metadata_keys=self.excluded_embed_metadata_keys,
            excluded_llm_metadata_keys=self.excluded_llm_metadata_keys,
            id=self.id_,
        )

    @classmethod
    def from_cloud_document(
        cls,
        doc: "CloudDocument",
    ) -> "Document":
        """Convert from LlamaCloud document type."""
        return Document(
            text=doc.text,
            metadata=doc.metadata,
            excluded_embed_metadata_keys=doc.excluded_embed_metadata_keys,
            excluded_llm_metadata_keys=doc.excluded_llm_metadata_keys,
            id_=doc.id,
        )


class ImageDocument(Document, ImageNode):
    """Data document containing an image."""

    @classmethod
    def class_name(cls) -> str:
        """
        Sets the name of its parent class to "ImageDocument".

        Returns:
            str: "ImageDocument".

        """
        return "ImageDocument"


@dataclass
class QueryBundle(DataClassJsonMixin):
    """
    Query bundle.

    This dataclass contains the original query string and associated transformations.

    Args:
        query_str (str): the original user-specified query string.
            This is currently used by all non embedding-based queries.
        custom_embedding_strs (list[str]): list of strings used for embedding the query.
            This is currently used by all embedding-based queries.
        embedding (list[float]): the stored embedding for the query.
    """

    query_str: str
    # using single image path as query input
    image_path: Optional[str] = None
    custom_embedding_strs: Optional[List[str]] = None
    embedding: Optional[List[float]] = None

    @property
    def embedding_strs(self) -> List[str]:
        """Use custom embedding strs if specified, otherwise use query str."""
        if self.custom_embedding_strs is None:
            if len(self.query_str) == 0:
                return []
            return [self.query_str]
        else:
            return self.custom_embedding_strs

    @property
    def embedding_image(self) -> List[ImageType]:
        """Use image path for image retrieval."""
        if self.image_path is None:
            return []
        return [self.image_path]

    def __str__(self) -> str:
        """Convert to string representation."""
        return self.query_str


QueryType = Union[str, QueryBundle]
